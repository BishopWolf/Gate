diff --git a/Gate.cc b/Gate.cc
index 0fab342..296c6db 100644
--- a/Gate.cc
+++ b/Gate.cc
@@ -51,7 +51,11 @@
 #ifdef G4UI_USE
 #include "G4UIExecutive.hh"
 #endif
-
+#ifdef G4MULTITHREADED
+#include "GateActionInitialization.hh"
+#include "G4MTRunManager.hh"
+#include "GateAnalysis.hh"
+#endif
 //-----------------------------------------------------------------------------
 void printHelpAndQuit( G4String msg )
 {
@@ -160,6 +164,9 @@ void welcome()
 #ifdef GATE_USE_GPU
   GateMessage("Core", 0, "GPU support activated" << G4endl );
 #endif
+#ifdef G4MULTITHREADED
+  GateMessage("Core", 0, "Multi Thread support activated" << G4endl );
+#endif
   GateMessage("Core", 0, G4endl);
 }
 //-----------------------------------------------------------------------------
@@ -268,11 +275,28 @@ int main( int argc, char* argv[] )
 
   // Construct the default run manager
   GateRunManager* runManager = new GateRunManager;
+#ifdef G4MULTITHREADED
+  G4int nThreads = G4Threading::G4GetNumberOfCores();
+  runManager->SetNumberOfThreads(nThreads); // Is equal to 2 by default
+#endif
+  
+  // Create various singleton objets
+#ifdef G4ANALYSIS_USE_GENERAL
+  GateOutputMgr::SetDigiMode( aDigiMode );
+  GateOutputMgr* outputMgr = GateOutputMgr::GetInstance();
+  GateDigitizer* digitizer = GateDigitizer::GetInstance();
+  GatePulseProcessorChain* singleChain = new GatePulseProcessorChain( digitizer, "Singles" );
+  digitizer->StoreNewPulseProcessorChain( singleChain );
+#endif
 
+#ifdef G4MULTITHREADED
+  GateAnalysis* myRecords = new GateAnalysis("analysis", outputMgr, aDigiMode);
+#else
   // Set the Basic ROOT Output
   GateRecorderBase* myRecords = 0;
 #ifdef G4ANALYSIS_USE_ROOT
   myRecords = new GateROOTBasicOutput;
+#endif  
 #endif
 
   // Set the DetectorConstruction
@@ -283,7 +307,7 @@ int main( int argc, char* argv[] )
   runManager->SetUserInitialization( GatePhysicsList::GetInstance() );
 
   // Set the users actions to handle callback for actors - before the initialisation
-  new GateUserActions( runManager, myRecords );
+  GateUserActions* myActions = new GateUserActions( runManager, myRecords );
 
   // Set the Visualization Manager
 #ifdef G4VIS_USE
@@ -297,15 +321,11 @@ int main( int argc, char* argv[] )
   runManager->InitializeAll();
 
   // Incorporate the user actions, set the particles generator
-  runManager->SetUserAction( new GatePrimaryGeneratorAction() );
-
-  // Create various singleton objets
-#ifdef G4ANALYSIS_USE_GENERAL
-  GateOutputMgr::SetDigiMode( aDigiMode );
-  GateOutputMgr* outputMgr = GateOutputMgr::GetInstance();
-  GateDigitizer* digitizer = GateDigitizer::GetInstance();
-  GatePulseProcessorChain* singleChain = new GatePulseProcessorChain( digitizer, "Singles" );
-  digitizer->StoreNewPulseProcessorChain( singleChain );
+#ifdef G4MULTITHREADED
+   // User action initialization  
+   runManager->SetUserInitialization( new GateActionInitialization( myActions, myRecords ) );
+#else
+   runManager->SetUserAction( new GatePrimaryGeneratorAction() );
 #endif
 
   if( aDigiMode == kofflineMode )
diff --git a/source/digits_hits/include/GateActionInitialization.hh b/source/digits_hits/include/GateActionInitialization.hh
new file mode 100644
index 0000000..f9cc16e
--- /dev/null
+++ b/source/digits_hits/include/GateActionInitialization.hh
@@ -0,0 +1,33 @@
+/*----------------------
+  Copyright (C): OpenGATE Collaboration
+
+  This software is distributed under the terms
+  of the GNU Lesser General  Public Licence (LGPL)
+  See GATE/LICENSE.txt for further details
+  ----------------------*/ 
+
+#ifndef GateActionInitialization_H
+#define GateActionInitialization_H
+
+#include "G4VUserActionInitialization.hh"
+#include "GateUserActions.hh"
+#include "GateRecorderBase.hh"
+
+class GateUserActions;
+class GateRecorderBase;
+
+class GateActionInitialization: public G4VUserActionInitialization
+{
+  public:
+    GateActionInitialization(GateUserActions * cbm, GateRecorderBase * r);
+    virtual ~GateActionInitialization();
+
+    virtual void BuildForMaster() const;
+    virtual void Build() const;
+
+private:
+    GateUserActions* pCallbackMan;
+    GateRecorderBase* recorder;
+};
+
+#endif
\ No newline at end of file
diff --git a/source/digits_hits/src/GateActionInitialization.cc b/source/digits_hits/src/GateActionInitialization.cc
new file mode 100644
index 0000000..1daf343
--- /dev/null
+++ b/source/digits_hits/src/GateActionInitialization.cc
@@ -0,0 +1,52 @@
+/*----------------------
+  Copyright (C): OpenGATE Collaboration
+
+  This software is distributed under the terms
+  of the GNU Lesser General  Public Licence (LGPL)
+  See GATE/LICENSE.txt for further details
+  ----------------------*/
+
+#include "GateActionInitialization.hh"
+#include "GatePrimaryGeneratorAction.hh"
+#include "GateActions.hh"
+#include "GateUserActions.hh"
+#include "GateRecorderBase.hh"
+#include "G4RunManager.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
+
+GateActionInitialization::GateActionInitialization(GateUserActions * cbm, GateRecorderBase * r):
+G4VUserActionInitialization(), pCallbackMan(cbm), recorder(r)
+{}
+
+GateActionInitialization::~GateActionInitialization()
+{}
+
+void GateActionInitialization::BuildForMaster() const
+{
+	// In MT mode, to be clearer, the RunAction class for the master thread might be
+	// different than the one used for the workers.
+	// This RunAction will be called before and after starting the
+	// workers.
+  //SetUserAction( new GateRunAction(pCallbackMan, recorder) ); 
+}
+
+void GateActionInitialization::Build() const
+{   
+ 
+  // Initialize the primary particles
+  GatePrimaryGeneratorAction* prim = new GatePrimaryGeneratorAction();  
+  SetUserAction( prim ); 
+
+  GateRunAction* run = new GateRunAction(pCallbackMan, recorder);
+  SetUserAction( run );
+
+  GateEventAction* event = new GateEventAction(pCallbackMan, recorder);
+  SetUserAction( event );
+  
+  SetUserAction( new GateTrackingAction(pCallbackMan, recorder));
+  SetUserAction( new GateSteppingAction(pCallbackMan, recorder));
+//SetUserAction( new GateStackingAction(pCallbackMan, recorder));
+	
+} 
\ No newline at end of file
diff --git a/source/digits_hits/src/GateActions.cc b/source/digits_hits/src/GateActions.cc
index bf2713b..9926b60 100644
--- a/source/digits_hits/src/GateActions.cc
+++ b/source/digits_hits/src/GateActions.cc
@@ -124,8 +124,11 @@ GateEventAction::GateEventAction(GateUserActions * cbm, GateRecorderBase* r)
 inline void GateEventAction::BeginOfEventAction(const G4Event* anEvent)
 {
   GateMessage("Core", 2, "Begin Of Event " << anEvent->GetEventID() << "\n");
-
+#ifdef G4MULTITHREADED
+  TrackingMode theMode =( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#else
   TrackingMode theMode =( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#endif
   if ( theMode != kTracker )
     {
       if (GetFlagBasicOutput()){
@@ -165,8 +168,11 @@ inline void GateEventAction::EndOfEventAction(const G4Event* anEvent)
 #endif
 
   /* PY Descourt 08/09/2009 */
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = ( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) );
+#else
   GateSteppingAction* myAction = ( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) );
+#endif
   TrackingMode theMode = myAction->GetMode();
 
   if ( theMode == kTracker )
@@ -222,9 +228,11 @@ void GateTrackingAction::PreUserTrackingAction(const G4Track* a)
   }
 
   /* PY Descourt 08/09/2009 */
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction*  myAction = (GateSteppingAction *) (G4MTRunManager::GetRunManager()->GetUserSteppingAction()) ;
+#else
   GateSteppingAction*  myAction = (GateSteppingAction *) (G4RunManager::GetRunManager()->GetUserSteppingAction()) ;
-
+#endif
   TrackingMode theMode = myAction->GetMode();
 
   if ( theMode == kDetector )
@@ -310,8 +318,11 @@ void GateTrackingAction::PostUserTrackingAction(const G4Track* aTrack)
         delete dummy_step_vector[i];
       dummy_step_vector.clear();
     }
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction*  myAction = (GateSteppingAction *) (G4MTRunManager::GetRunManager()->GetUserSteppingAction()) ;
+#else
   GateSteppingAction*  myAction = (GateSteppingAction *) (G4RunManager::GetRunManager()->GetUserSteppingAction()) ;
+#endif
   TrackingMode theMode = myAction->GetMode();
   if ( theMode == kDetector )
     {
@@ -776,7 +787,11 @@ void GateSteppingAction::UserSteppingAction(const G4Step* theStep)
   if ( TheMode == kTracker )
     {
       G4int EventID = G4EventManager::GetEventManager()->GetNonconstCurrentEvent()->GetEventID();
+#ifdef G4MULTITHREADED
+      G4int RunID   = G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#else
       G4int RunID   = G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#endif
       G4Track * fTrack = theStep->GetTrack();
       G4int ParentID  =  fTrack->GetParentID();
       G4int TrackID = fTrack->GetTrackID();
@@ -1026,7 +1041,11 @@ void GateSteppingAction::UserSteppingAction(const GateVVolume *v, const G4Step*
   G4bool drawTrj = false;
   if (m_drawTrjLevel == 0) {
   } else if (m_drawTrjLevel == 1) {
+#ifdef G4MULTITHREADED
+    G4int currentEvent = G4MTRunManager::GetRunManager()->GetCurrentEvent()->GetEventID();
+#else
     G4int currentEvent = G4RunManager::GetRunManager()->GetCurrentEvent()->GetEventID();
+#endif
     if (currentEvent <= 10) {
       drawTrj = true;
     }
@@ -1238,7 +1257,11 @@ void GateSteppingAction::UserSteppingAction(const GateVVolume *v, const G4Step*
   if ( TheMode == kTracker )
     {
       G4int EventID = G4EventManager::GetEventManager()->GetNonconstCurrentEvent()->GetEventID();
+#ifdef G4MULTITHREADED
+      G4int RunID   = G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#else
       G4int RunID   = G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#endif
       G4Track * fTrack = theStep->GetTrack();
       G4int ParentID  =  fTrack->GetParentID();
       G4int TrackID = fTrack->GetTrackID();
diff --git a/source/digits_hits/src/GateAnalysis.cc b/source/digits_hits/src/GateAnalysis.cc
index f5f4a33..3b6e503 100644
--- a/source/digits_hits/src/GateAnalysis.cc
+++ b/source/digits_hits/src/GateAnalysis.cc
@@ -35,6 +35,9 @@
 #include "GateVVolume.hh"
 #include "GateActions.hh"
 #include "GateToRoot.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 //--------------------------------------------------------------------------------------------------
 GateAnalysis::GateAnalysis(const G4String& name, GateOutputMgr* outputMgr,DigiMode digiMode)
   : GateVOutputModule(name,outputMgr,digiMode)
@@ -125,7 +128,11 @@ void GateAnalysis::RecordEndOfEvent(const G4Event* event)
     m_trajectoryNavigator->SetTrajectoryContainer(trajectoryContainer);
 
   G4int eventID = event->GetEventID();
+#ifdef G4MULTITHREADED
+  G4int runID   = G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#else
   G4int runID   = G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#endif
   //G4cout << "GateAnalysis::EventID et RunID :  " <<eventID<<" - "<<runID<< G4endl;
 
   //G4int i;
@@ -317,8 +324,11 @@ void GateAnalysis::RecordEndOfEvent(const G4Event* event)
                     }
                 }
             } // end loop NpHits
-
+#ifdef G4MULTITHREADED
+          TrackingMode theMode =( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#else
           TrackingMode theMode =( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#endif
 
 
           if (  theMode == kTracker ) // in tracker mode we store the infos about the number of compton and rayleigh
diff --git a/source/digits_hits/src/GateFastAnalysis.cc b/source/digits_hits/src/GateFastAnalysis.cc
index 081bd0c..3fe0d79 100644
--- a/source/digits_hits/src/GateFastAnalysis.cc
+++ b/source/digits_hits/src/GateFastAnalysis.cc
@@ -24,6 +24,9 @@ See GATE/LICENSE.txt for further details
 #include "GateCrystalHit.hh"
 #include "GateSourceMgr.hh"
 #include "GateOutputMgr.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 GateFastAnalysis::GateFastAnalysis(const G4String& name, GateOutputMgr* outputMgr, DigiMode digiMode)
   : GateVOutputModule(name,outputMgr,digiMode)
@@ -86,7 +89,11 @@ void GateFastAnalysis::RecordEndOfEvent(const G4Event* event)
 
     G4int sourceID = (((GateSourceMgr::GetInstance())->GetSourcesForThisEvent())[0])->GetSourceID();
     G4int eventID  = event->GetEventID();
+#ifdef G4MULTITHREADED
+    G4int runID    = G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#else
     G4int runID    = G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#endif
 
         for (G4int iHit=0;iHit<NbHits;iHit++)
            {
diff --git a/source/digits_hits/src/GateFluenceActor.cc b/source/digits_hits/src/GateFluenceActor.cc
index 865215d..5d8ab92 100644
--- a/source/digits_hits/src/GateFluenceActor.cc
+++ b/source/digits_hits/src/GateFluenceActor.cc
@@ -124,7 +124,11 @@ void GateFluenceActor::Construct()
 /// Save data
 void GateFluenceActor::SaveData()
 {
+#ifdef G4MULTITHREADED
+  G4int rID = G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#else
   G4int rID = G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#endif
   char filename[1024];
   // Printing all particles
   GateVImageActor::SaveData();
diff --git a/source/digits_hits/src/GatePhaseSpaceActor.cc b/source/digits_hits/src/GatePhaseSpaceActor.cc
index c7b522c..e3c29b1 100644
--- a/source/digits_hits/src/GatePhaseSpaceActor.cc
+++ b/source/digits_hits/src/GatePhaseSpaceActor.cc
@@ -378,10 +378,17 @@ void GatePhaseSpaceActor::UserSteppingAction(const GateVVolume *, const G4Step *
                    << " stepPoint time proper=" << G4BestUnit(stepPoint->GetProperTime(), "Time")
                    << " global=" << G4BestUnit(stepPoint->GetGlobalTime(), "Time")
                    << " local=" << G4BestUnit(stepPoint->GetLocalTime(), "Time") << G4endl);
+#ifdef G4MULTITHREADED
+  GateDebugMessage("Actor", 4, "trackid="
+                   << step->GetTrack()->GetParentID()
+                   << " event=" << G4MTRunManager::GetRunManager()->GetCurrentEvent()->GetEventID()
+                   << " run=" << G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID() << G4endl);
+#else
   GateDebugMessage("Actor", 4, "trackid="
                    << step->GetTrack()->GetParentID()
                    << " event=" << G4RunManager::GetRunManager()->GetCurrentEvent()->GetEventID()
                    << " run=" << G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID() << G4endl);
+#endif
   GateDebugMessage("Actor", 4, "pos = " << x << " " << y  << " " << z << G4endl);
   GateDebugMessage("Actor", 4, "E = " << G4BestUnit(stepPoint->GetKineticEnergy(), "Energy") << G4endl);
 
diff --git a/source/digits_hits/src/GateSignalHandler.cc b/source/digits_hits/src/GateSignalHandler.cc
index a14a254..da2d42c 100644
--- a/source/digits_hits/src/GateSignalHandler.cc
+++ b/source/digits_hits/src/GateSignalHandler.cc
@@ -87,8 +87,11 @@ void GateSignalHandler::QuitSignalHandler(int sig)
 
       // If a beamOn/StartDAQ is running, launch abort sequence
       G4cerr << "--- Aborting run/acquisition! ---" << G4endl << G4endl;
-
+#ifdef G4MULTITHREADED
+      G4MTRunManager::GetRunManager()->AbortRun(true);
+#else
       G4RunManager::GetRunManager()->AbortRun(true);
+#endif
 
       GateApplicationMgr::GetInstance()->StopDAQ();
       break;
diff --git a/source/digits_hits/src/GateToASCII.cc b/source/digits_hits/src/GateToASCII.cc
index 7bce5fa..319bb21 100644
--- a/source/digits_hits/src/GateToASCII.cc
+++ b/source/digits_hits/src/GateToASCII.cc
@@ -38,6 +38,9 @@
 #include "G4Positron.hh"
 #include "G4GenericIon.hh"
 #include "G4DigiManager.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 #include <iomanip>
 #include <iostream>
@@ -147,8 +150,13 @@ void GateToASCII::RecordEndOfRun(const G4Run * )
   if (nVerboseLevel > 2)
     G4cout << "GateToASCII::RecordEndOfRun" << G4endl;
   if (m_outFileRunsFlag) {
+#ifdef G4MULTITHREADED
+    G4int nEvent = ((GatePrimaryGeneratorAction*)G4MTRunManager::GetRunManager()->
+		    GetUserPrimaryGeneratorAction())->GetEventNumber();
+#else
     G4int nEvent = ((GatePrimaryGeneratorAction*)G4RunManager::GetRunManager()->
 		    GetUserPrimaryGeneratorAction())->GetEventNumber();
+#endif
     if (nVerboseLevel > 0) G4cout
       << "GateToASCII::RecordEndOfRun: Events in the past run: " << nEvent << G4endl;
     m_outFileRun
diff --git a/source/digits_hits/src/GateToBinary.cc b/source/digits_hits/src/GateToBinary.cc
index 2c1e384..ad80ec8 100644
--- a/source/digits_hits/src/GateToBinary.cc
+++ b/source/digits_hits/src/GateToBinary.cc
@@ -20,6 +20,9 @@
 #include "GateOutputMgr.hh"
 #include "GateVGeometryVoxelStore.hh"
 #include "G4DigiManager.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 // 0x79000000 equivalent to 2,030,043,136 bytes
 #define LIMIT_SIZE 0x79000000
@@ -136,10 +139,15 @@ void GateToBinary::RecordEndOfRun( G4Run const* )
 
 	if( m_outFileRunsFlag )
 	{
+#ifdef G4MULTITHREADED
+		G4int nEvent =
+			( ( (GatePrimaryGeneratorAction*)G4MTRunManager::GetRunManager()->
+			GetUserPrimaryGeneratorAction())->GetEventNumber() );
+#else
 		G4int nEvent =
 			( ( (GatePrimaryGeneratorAction*)G4RunManager::GetRunManager()->
 			GetUserPrimaryGeneratorAction())->GetEventNumber() );
-
+#endif
 		if( nVerboseLevel > 0 )
 		{
 			G4cout << "GateToBinary::RecordEndOfRun: Events in the past run: "
diff --git a/source/digits_hits/src/GateToGPUImageSPECT.cc b/source/digits_hits/src/GateToGPUImageSPECT.cc
index 17cd577..9d174ba 100644
--- a/source/digits_hits/src/GateToGPUImageSPECT.cc
+++ b/source/digits_hits/src/GateToGPUImageSPECT.cc
@@ -12,7 +12,6 @@
 #include "GateConfiguration.h"
 #include "G4VProcess.hh"
 #include "G4UnitsTable.hh"
-#include "G4RunManager.hh"
 #include "G4EmCalculator.hh"
 #include "G4TouchableHistory.hh"
 #include "G4TransportationManager.hh"
diff --git a/source/digits_hits/src/GateToImageCT.cc b/source/digits_hits/src/GateToImageCT.cc
index 5bbc928..e9882b5 100644
--- a/source/digits_hits/src/GateToImageCT.cc
+++ b/source/digits_hits/src/GateToImageCT.cc
@@ -19,6 +19,9 @@
 #include "G4EmCalculator.hh"
 #include "G4TouchableHistory.hh"
 #include "G4TransportationManager.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 #include "GateOutputMgr.hh"
 #include "GateToImageCT.hh"
@@ -386,7 +389,11 @@ void GateToImageCT::RecordBeginOfEvent( const G4Event* aEvent )
   if( fabs( newPosition.getX() ) > m_detectorInX / 2
       || fabs( newPosition.getY() )  > m_detectorInY / 2 )
     {
+#ifdef G4MULTITHREADED
+      G4MTRunManager::GetRunManager()->AbortEvent();
+#else
       G4RunManager::GetRunManager()->AbortEvent();
+#endif
       if ( nVerboseLevel > 1 )
         G4cout << " Abort event: Out of detector section "<< G4endl;
     }
diff --git a/source/digits_hits/src/GateToRoot.cc b/source/digits_hits/src/GateToRoot.cc
index f0e3c24..1fcca01 100644
--- a/source/digits_hits/src/GateToRoot.cc
+++ b/source/digits_hits/src/GateToRoot.cc
@@ -40,6 +40,9 @@
 #include "G4Positron.hh"
 #include "G4GenericIon.hh"
 #include "G4Gamma.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 #include "GateCrystalHit.hh"
 #include "GatePhantomHit.hh"
@@ -281,8 +284,11 @@ void GateToRoot::RecordBeginOfAcquisition()
 
   if (nVerboseLevel > 2)
     G4cout << "GateToRoot::RecordBeginOfAcquisition" << G4endl;
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = ( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) );  
+#else
   GateSteppingAction* myAction = ( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) );
+#endif
   TrackingMode theMode = myAction->GetMode();
   if (nVerboseLevel > 1) G4cout << " GateToRoot::RecordBeginOfAcquisition()  Tracking Mode " << theMode << G4endl;
 
@@ -512,8 +518,11 @@ void GateToRoot::RecordEndOfAcquisition()
     }
 
   /* PY Descourt 08/09/2009 */
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = ( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) );
+#else
   GateSteppingAction* myAction = ( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) );
+#endif
   TrackingMode theMode = myAction->GetMode();
   if ( theMode == kTracker )
     {
@@ -649,8 +658,11 @@ void GateToRoot::RecordBeginOfEvent(const G4Event* evt )
   strcpy( theCRData.theRayleighVolumeName1, G4String("NULL").c_str()  );
   strcpy( theCRData.theRayleighVolumeName2, G4String("NULL").c_str()  );
 
-
+#ifdef G4MULTITHREADED
+  TrackingMode theMode =( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();  
+#else
   TrackingMode theMode =( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#endif
   if ( (theMode == kDetector) &&   (evt->GetNumberOfPrimaryVertex() > 0) )
     {
 
@@ -690,9 +702,11 @@ void GateToRoot::RecordEndOfEvent(const G4Event* event)
 {
 
   // GateMessage("Output", 5 , " GateToRoot::RecordEndOfEvent -- begin" << G4endl;);
-
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = ( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) );
+#else
   GateSteppingAction* myAction = ( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) );
+#endif
   TrackingMode theMode = myAction->GetMode();
   if ( theMode == kTracker )return;
 
@@ -786,8 +800,13 @@ void GateToRoot::RecordEndOfEvent(const G4Event* event)
       } else {
 	//! better than the simple eventID, but still not enough: it's valid only for
 	//! the single run and not for the application
+#ifdef G4MULTITHREADED
+	G4int iEvent = ((GatePrimaryGeneratorAction*)G4MTRunManager::GetRunManager()->
+			GetUserPrimaryGeneratorAction())->GetEventNumber();
+#else
 	G4int iEvent = ((GatePrimaryGeneratorAction*)G4RunManager::GetRunManager()->
 			GetUserPrimaryGeneratorAction())->GetEventNumber();
+#endif
 	if (m_rootNtupleFlag) ntuple->Fill(iEvent,
 					   eventTime/s,
 					   m_positronKinEnergy/MeV,
@@ -1289,9 +1308,11 @@ void GateToRoot::OpenTracksFile()
 
   G4int lastEventID = -1;
   G4String previousFN = fTracksFN ;
-
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = ( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) );
+#else
   GateSteppingAction* myAction = ( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) );
+#endif
 
   G4int currentN = myAction->GetcurrentN();
 
@@ -1474,7 +1495,12 @@ void GateToRoot::GetCurrentRecStepData( const G4Event* evt )
   //PrintRecStep();
 
   if ( m_RSEventID != evt->GetEventID() )
-    {const G4Run* currentRun =  G4RunManager::GetRunManager()->GetCurrentRun() ;
+    {
+#ifdef G4MULTITHREADED
+      const G4Run* currentRun =  G4MTRunManager::GetRunManager()->GetCurrentRun() ;      
+#else
+      const G4Run* currentRun =  G4RunManager::GetRunManager()->GetCurrentRun() ;
+#endif
       G4int RunID = currentRun->GetRunID();
       G4cout << " GateToRoot::GetCurrentRecStepData :::: current Run ID "<< RunID <<"    current RecStep File " <<m_RecStepTree->GetCurrentFile()->GetName()<<G4endl;
       G4cout << " GateToRoot::GetCurrentRecStepData :::: m_currentTracksData = "<<m_currentTracksData  <<"     tracksTuple->GetEntries()   "<< tracksTuple->GetEntries() <<G4endl;
@@ -1489,7 +1515,11 @@ void GateToRoot::GetCurrentRecStepData( const G4Event* evt )
 
 GateTrack* GateToRoot::GetCurrentTracksData()
 {
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = ( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) );  
+#else
   GateSteppingAction* myAction = ( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) );
+#endif
   if ( m_currentTracksData ==  tracksTuple->GetEntries() ) // check if we are done
     {
       m_EOF = 1;
@@ -1553,7 +1583,11 @@ void GateToRoot::RecordRecStepData( const G4Event* evt )
 {
   //G4cout << " GateToRoot::RecordRecStepData : recording RecStep Data to ROOT file " << G4endl;
   m_RSEventID = evt->GetEventID();
+#ifdef G4MULTITHREADED
+  m_RSRunID   = G4MTRunManager::GetRunManager()->GetCurrentRun()->GetRunID();  
+#else
   m_RSRunID   = G4RunManager::GetRunManager()->GetCurrentRun()->GetRunID();
+#endif
   m_RecStepTree->Fill();
   //PrintRecStep();
   //G4cout << " GateToRoot::RecordRecStepData : runID " << m_RSRunID << "  eventID "<< m_RSEventID  << G4endl;
diff --git a/source/digits_hits/src/GateTrajectoryNavigator.cc b/source/digits_hits/src/GateTrajectoryNavigator.cc
index 4ad346a..b4b715a 100644
--- a/source/digits_hits/src/GateTrajectoryNavigator.cc
+++ b/source/digits_hits/src/GateTrajectoryNavigator.cc
@@ -118,8 +118,11 @@ G4int GateTrajectoryNavigator::FindPositronTrackID()
 /* modifs pour cas du mode detector : PY Descourt 08/09/2009 */
 std::vector<G4int> GateTrajectoryNavigator::FindAnnihilationGammasTrackID()
 {
-
+#ifdef G4MULTITHREADED
+TrackingMode theMode =( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();  
+#else
 TrackingMode theMode =( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#endif
 
   if (nVerboseLevel > 2)
     G4cout << "GateTrajectoryNavigator::FindAnnihilationGammasTrackID" << G4endl;
diff --git a/source/general/include/GateRunManager.hh b/source/general/include/GateRunManager.hh
index c4164d9..b72327b 100644
--- a/source/general/include/GateRunManager.hh
+++ b/source/general/include/GateRunManager.hh
@@ -28,12 +28,19 @@
 #define GateRunManager_h 1
 
 #include "G4RunManager.hh"
+#ifdef G4MULTITHREADED
+ #include "G4MTRunManager.hh"
+#endif
 #include "GateHounsfieldToMaterialsBuilder.hh"
 
 class GateRunManagerMessenger;
 class GateDetectorConstruction;
 
+#ifdef G4MULTITHREADED
+class GateRunManager : public G4MTRunManager
+#else
 class GateRunManager : public G4RunManager
+#endif
 {
 public:
   //! Constructor
@@ -60,8 +67,11 @@ public:
 
   //! Return the instance of the run manager
   static GateRunManager* GetRunManager()
+  #ifdef G4MULTITHREADED
+  {	return dynamic_cast<GateRunManager*>(G4MTRunManager::GetRunManager()); }
+  #else
   {	return dynamic_cast<GateRunManager*>(G4RunManager::GetRunManager()); }
-
+  #endif
   bool GetGlobalOutputFlag() { return mGlobalOutputFlag; }
   void EnableGlobalOutput(bool b) { mGlobalOutputFlag = b; }
   void SetUserPhysicList(G4VUserPhysicsList * m) { mUserPhysicList = m; }
diff --git a/source/general/src/GateApplicationMgr.cc b/source/general/src/GateApplicationMgr.cc
index d073861..e657180 100644
--- a/source/general/src/GateApplicationMgr.cc
+++ b/source/general/src/GateApplicationMgr.cc
@@ -709,7 +709,11 @@ void GateApplicationMgr::EnableTimeStudyForSteps(G4String filename)
 
 void GateApplicationMgr::PrintStatus()
 {
+#ifdef G4MULTITHREADED
+    const G4Run * run = G4MTRunManager::GetRunManager()->GetCurrentRun();
+#else
     const G4Run * run = G4RunManager::GetRunManager()->GetCurrentRun();
+#endif
     const int runID = run->GetRunID() + 1;
     const int runTotal = listOfTimeSlice.size();
 
diff --git a/source/general/src/GateMiscFunctions.cc b/source/general/src/GateMiscFunctions.cc
index 7acd5bc..0f2a5a6 100644
--- a/source/general/src/GateMiscFunctions.cc
+++ b/source/general/src/GateMiscFunctions.cc
@@ -23,6 +23,9 @@ See GATE/LICENSE.txt for further details
 #include "G4ThreeVector.hh"
 #include "G4RunManager.hh"
 #include "G4Run.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 #include <sys/types.h> 
 #include <sys/file.h>
@@ -670,7 +673,11 @@ int GetIndexFromTime(std::vector<double> & mTimeList, double aTime) {
 G4String GetSaveCurrentFilename(G4String & mSaveFilename) {
   int nr=0;
   int ne=0;
+#ifdef G4MULTITHREADED
+  const G4Run * run = G4MTRunManager::GetRunManager()->GetCurrentRun();  
+#else
   const G4Run * run = G4RunManager::GetRunManager()->GetCurrentRun();
+#endif
   if (run) nr = run->GetRunID(); 
   else {
     nr = 0;
diff --git a/source/general/src/GatePrimaryGeneratorAction.cc b/source/general/src/GatePrimaryGeneratorAction.cc
index 9188750..040e869 100644
--- a/source/general/src/GatePrimaryGeneratorAction.cc
+++ b/source/general/src/GatePrimaryGeneratorAction.cc
@@ -12,6 +12,9 @@ See GATE/LICENSE.txt for further details
 #include "G4GeneralParticleSource.hh"
 #include "G4ParticleGun.hh"
 #include "G4UImanager.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 #include "Randomize.hh"
 #include "G4ios.hh"
@@ -98,7 +101,11 @@ void GatePrimaryGeneratorAction::GenerateSimulationPrimaries(G4Event* event)
   G4int eventID = event->GetEventID();
   GateSourceMgr* sourceMgr = GateSourceMgr::GetInstance();
   if (eventID==0) {
+#ifdef G4MULTITHREADED
+    const G4Run* currentRun = G4MTRunManager::GetRunManager()->GetCurrentRun();
+#else
     const G4Run* currentRun = G4RunManager::GetRunManager()->GetCurrentRun();
+#endif
     //if( currentRun->GetRunID()==0) sourceMgr->Initialization();
     sourceMgr->PrepareNextRun( currentRun );
     m_nEvents=0;
@@ -107,8 +114,11 @@ void GatePrimaryGeneratorAction::GenerateSimulationPrimaries(G4Event* event)
   G4int numVertices = sourceMgr->PrepareNextEvent(event);  
   //! stop the run if no particle has been generated by the source manager
   if (numVertices == 0) {
+#ifdef G4MULTITHREADED
+    G4MTRunManager* runManager = G4MTRunManager::GetMasterRunManager();
+#else
     G4RunManager* runManager = G4RunManager::GetRunManager();
-
+#endif
     runManager->AbortRun(true);
     if (m_nVerboseLevel>1) G4cout << "GatePrimaryGeneratorAction::GeneratePrimaries: numVertices == 0, run aborted " << G4endl;  
   } 
diff --git a/source/general/src/GateRunManager.cc b/source/general/src/GateRunManager.cc
index 2604e47..e05c6b4 100644
--- a/source/general/src/GateRunManager.cc
+++ b/source/general/src/GateRunManager.cc
@@ -8,6 +8,9 @@
 
 
 #include "GateRunManager.hh"
+#ifdef G4MULTITHREADED
+ #include "G4MTRunManager.hh"
+#endif
 #include "GateDetectorConstruction.hh"
 #include "GateRunManagerMessenger.hh"
 #include "GateHounsfieldToMaterialsBuilder.hh"
@@ -27,7 +30,11 @@
 #endif
 
 //----------------------------------------------------------------------------------------
+#ifdef G4MULTITHREADED
+GateRunManager::GateRunManager():G4MTRunManager()
+#else
 GateRunManager::GateRunManager():G4RunManager()
+#endif
 {
   pMessenger = new GateRunManagerMessenger(this);
   mHounsfieldToMaterialsBuilder = new GateHounsfieldToMaterialsBuilder();
@@ -62,7 +69,11 @@ void GateRunManager::InitializeAll()
   if (currentState!=G4State_PreInit && currentState!=G4State_Idle)
     {
       G4cerr << "Illegal application state - "
-	     << "G4RunManager::Initialize() ignored." << G4endl;
+      #ifdef G4MULTITHREADED
+	     << "G4MTRunManager::Initialize() ignored." << G4endl;
+#else
+	     << "G4RunManager::Initialize() ignored." << G4endl; 
+#endif
       return;
     }
 
@@ -112,7 +123,11 @@ void GateRunManager::InitializeAll()
                                                                     G4ProductionCutsTable::GetProductionCutsTable()->GetHighEdgeEnergy());
 
     // Initialization
+#ifdef G4MULTITHREADED
+    G4MTRunManager::SetUserInitialization(mUserPhysicList);
+#else
     G4RunManager::SetUserInitialization(mUserPhysicList);
+#endif
 
     //To take into account the user cuts (steplimiter and special cuts)
 #if (G4VERSION_MAJOR > 9)
@@ -126,7 +141,11 @@ void GateRunManager::InitializeAll()
   } // End if (mUserPhysicListName != "")
 
   // InitializePhysics
+#ifdef G4MULTITHREADED
   G4RunManager::InitializePhysics();
+#else
+  G4MTRunManager::InitializePhysics();
+#endif
 
   // Take into account the em option set by the user (dedx bin etc)
   GatePhysicsList::GetInstance()->SetEmProcessOptions();
@@ -169,7 +188,11 @@ void GateRunManager::InitGeometryOnly()
   if (!geometryInitialized)
     {
       GateMessage("Core", 1, "Initialization of geometry" << G4endl);
+#ifdef G4MULTITHREADED
+      G4MTRunManager::InitializeGeometry();
+#else
       G4RunManager::InitializeGeometry();
+#endif
     }
   else
     {
@@ -189,7 +212,11 @@ void GateRunManager::InitGeometryOnly()
 //----------------------------------------------------------------------------------------
 void GateRunManager::InitPhysics()
 {
+  #ifdef G4MULTITHREADED
+  G4MTRunManager::InitializePhysics();
+#else
   G4RunManager::InitializePhysics();
+#endif
 }
 //----------------------------------------------------------------------------------------
 
@@ -205,7 +232,11 @@ void GateRunManager::RunInitialization()
 
   // GateMessage("Core", 0, "Initialization of the run " << G4endl);
   // Perform a regular initialisation
+  #ifdef G4MULTITHREADED
+  G4MTRunManager::RunInitialization();
+#else
   G4RunManager::RunInitialization();
+#endif
 
   // Initialization of the atom deexcitation processes
   // must be done after all other initialization
diff --git a/source/physics/src/GateSourceMgr.cc b/source/physics/src/GateSourceMgr.cc
index 224cce0..dc7b025 100644
--- a/source/physics/src/GateSourceMgr.cc
+++ b/source/physics/src/GateSourceMgr.cc
@@ -29,6 +29,9 @@
 #include <cmath>
 #include "GateActions.hh"
 #include "G4RunManager.hh"
+#ifdef G4MULTITHREADED
+#include "G4MTRunManager.hh"
+#endif
 
 //----------------------------------------------------------------------------------------
 GateSourceMgr* GateSourceMgr::mInstance = 0;
@@ -525,8 +528,11 @@ G4int GateSourceMgr::PrepareNextEvent( G4Event* event )
 {
   // GateDebugMessage("Acquisition", 0, "PrepareNextEvent "  << event->GetEventID()
   //                    << " at time " << m_time/s << " sec." << G4endl);
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = (GateSteppingAction *) ( G4MTRunManager::GetRunManager()->GetUserSteppingAction() );
+#else
   GateSteppingAction* myAction = (GateSteppingAction *) ( G4RunManager::GetRunManager()->GetUserSteppingAction() );
+#endif
   TrackingMode theMode =myAction->GetMode();
   m_currentSources.clear();
 
diff --git a/source/physics/src/GateVSource.cc b/source/physics/src/GateVSource.cc
index 8d61fa9..83525d8 100644
--- a/source/physics/src/GateVSource.cc
+++ b/source/physics/src/GateVSource.cc
@@ -444,9 +444,11 @@ G4int GateVSource::GeneratePrimaries( G4Event* event )
   if (event) GateMessage("Beam", 2, "Generating particle " << event->GetEventID() << G4endl);
   
   G4int numVertices = 0;
-
+#ifdef G4MULTITHREADED
+  GateSteppingAction* myAction = (GateSteppingAction *) ( G4MTRunManager::GetRunManager()->GetUserSteppingAction() );  
+#else
   GateSteppingAction* myAction = (GateSteppingAction *) ( G4RunManager::GetRunManager()->GetUserSteppingAction() );
-
+#endif
   TrackingMode theMode =myAction->GetMode();
 
   G4bool test = (theMode ==1 ) || ( theMode == 2 );
@@ -534,7 +536,11 @@ G4int GateVSource::GeneratePrimaries( G4Event* event )
           numVertices = 0;
           return numVertices;
         }
+#ifdef G4MULTITHREADED
+      G4Run* currentRun = const_cast<G4Run*> ( G4MTRunManager::GetRunManager()->GetCurrentRun() );  
+#else
       G4Run* currentRun = const_cast<G4Run*> ( G4RunManager::GetRunManager()->GetCurrentRun() );
+#endif
       currentRun->SetRunID( m_currentTrack->GetRunID() );
       event->SetEventID( m_currentTrack->GetEventID() );
       G4int event_id =  m_currentTrack->GetEventID();
@@ -665,7 +671,11 @@ void GateVSource::GeneratePrimaryVertex( G4Event* aEvent )
   }
 
   /* PY Descourt 08/09/2009 */  
+#ifdef G4MULTITHREADED
+  TrackingMode theMode =( (GateSteppingAction *)(G4MTRunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#else
   TrackingMode theMode =( (GateSteppingAction *)(G4RunManager::GetRunManager()->GetUserSteppingAction() ) )->GetMode();
+#endif
   if (  theMode == kBoth || theMode == kTracker ) 
     {
       G4ThreeVector particle_position;

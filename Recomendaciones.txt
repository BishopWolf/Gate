 
Dear Alex,

    Thank for your work and message. I see you got the bulk of the MT. I put below several things to look at / consider. Please note I know mostly nothing on Gate code itself...

    To summarize the issues, the "pCallbackMan" and "recorder" arguments in the action initialization need some design consideration as threads will very likely conflict on these objects. I would guess that the most significant issues will be here. Please see below for more details.

    I'll be happy to help more if I can, or involve some of the G4 experts on MT if needed !

Cheers,
Marc


o The lines:
    G4int nThreads = G4Threading::G4GetNumberOfCores();
    runManager->SetNumberOfThreads(nThreads); // Is equal to 2 by default

    are correct. Please note that you may use this number as a maximum number of threads, not the number by default.
    For debugging purpose, I would suggest to start with 2 cores only, and when the case looks clean, augment the number of cores.

o The line:
    runManager->SetUserInitialization( GatePhysicsList::GetInstance() );

    looks correct to me.
    One question is that if Gate had implemented "home made physics processes" (G4VProcess) in this physics list ? If so, they should comply to the new G4VProcess interface, which has methods for the MT case.

o There are several lines with potential problems (I gather together lines concerned):
    // Set the Basic ROOT Output
    GateRecorderBase* myRecords = 0;

    --> ** ROOT is not thread safe ! ** For this reason, Geant4 is providing, in the "analysis" package, many, but not all, of the ROOT functionalities to create histograms and trees. The histograms are filled in each thread, and their content are merged at the end of the job. The trees are dumped individually by the threads (not merged) and should be analyzed using a chain.
    In a first stage, I would recommend to switch off the recording, to get rest of the machinery right, and then include the output functionalities.


    // Set the users actions to handle callback for actors - before the initialisation
    GateUserActions* myActions = new GateUserActions( runManager, myRecords );
    runManager->SetUserInitialization( new GateActionInitialization( myActions, myRecords ) );
    and the constructor:
    GateActionInitialization(GateUserActions * cbm, GateRecorderBase * r);
    with the lines in the GateActionInitialization class with arguments "pCallbackMan, recorder", specially in the Build() method.

    --> very likely this will not work. 'pCallbackMan' and 'recorder' are the same objects, share among the threads the way they are created and passed to the action initialization. What will happen is that they will be messaged at whatever times by the threads during the event loop -thread 1 is calling method a() and while a() is processed, method b() is called by thread 2, and thread 3 re-calls a(), still processed by thread 1; if inside these methods data members are changed, this will result in a unpredictable behavior-. The recorder, I understand is the ROOT based class, should be redesigned using "analysis" to avoid these conflicts and one instance of it (a priori) should be made per thread to make the recording independent among these threads.
    For pCallbackMan, I admit my ignorance. It looks to be a configuration class (correct ?) being read only at that time. Is this correct ? If so, this should not be too problematic. But certainly, some iteration is needed here.

o At first sight, the rest looks fine to me. One comment is that the "action initialisation" mechanism works also for the usual G4RunManager, so that some #ifdef ... #endif could be removed. In the G4RunManager case, the BuildForMaster() is ignored.